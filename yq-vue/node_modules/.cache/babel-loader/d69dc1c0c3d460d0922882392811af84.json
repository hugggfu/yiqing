{"ast":null,"code":"import \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/esnext.typed-array.find-last.js\";\nimport \"core-js/modules/esnext.typed-array.find-last-index.js\";\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { assert, clone, createHashMap, isFunction, keys, map, reduce } from 'zrender/lib/core/util.js';\nimport { parseDataValue } from './helper/dataValueHelper.js';\nimport { shouldRetrieveDataByName } from './Source.js';\nvar UNDEFINED = 'undefined';\n/* global Float64Array, Int32Array, Uint32Array, Uint16Array */\n// Caution: MUST not use `new CtorUint32Array(arr, 0, len)`, because the Ctor of array is\n// different from the Ctor of typed array.\n\nexport var CtorUint32Array = typeof Uint32Array === UNDEFINED ? Array : Uint32Array;\nexport var CtorUint16Array = typeof Uint16Array === UNDEFINED ? Array : Uint16Array;\nexport var CtorInt32Array = typeof Int32Array === UNDEFINED ? Array : Int32Array;\nexport var CtorFloat64Array = typeof Float64Array === UNDEFINED ? Array : Float64Array;\n/**\n * Multi dimensional data store\n */\n\nvar dataCtors = {\n  'float': CtorFloat64Array,\n  'int': CtorInt32Array,\n  // Ordinal data type can be string or int\n  'ordinal': Array,\n  'number': Array,\n  'time': CtorFloat64Array\n};\nvar defaultDimValueGetters;\n\nfunction getIndicesCtor(rawCount) {\n  // The possible max value in this._indicies is always this._rawCount despite of filtering.\n  return rawCount > 65535 ? CtorUint32Array : CtorUint16Array;\n}\n\n;\n\nfunction getInitialExtent() {\n  return [Infinity, -Infinity];\n}\n\n;\n\nfunction cloneChunk(originalChunk) {\n  var Ctor = originalChunk.constructor; // Only shallow clone is enough when Array.\n\n  return Ctor === Array ? originalChunk.slice() : new Ctor(originalChunk);\n}\n\nfunction prepareStore(store, dimIdx, dimType, end, append) {\n  var DataCtor = dataCtors[dimType || 'float'];\n\n  if (append) {\n    var oldStore = store[dimIdx];\n    var oldLen = oldStore && oldStore.length;\n\n    if (!(oldLen === end)) {\n      var newStore = new DataCtor(end); // The cost of the copy is probably inconsiderable\n      // within the initial chunkSize.\n\n      for (var j = 0; j < oldLen; j++) {\n        newStore[j] = oldStore[j];\n      }\n\n      store[dimIdx] = newStore;\n    }\n  } else {\n    store[dimIdx] = new DataCtor(end);\n  }\n}\n\n;\n/**\n * Basically, DataStore API keep immutable.\n */\n\nvar DataStore =\n/** @class */\nfunction () {\n  function DataStore() {\n    this._chunks = []; // It will not be calculated util needed.\n\n    this._rawExtent = [];\n    this._extent = [];\n    this._count = 0;\n    this._rawCount = 0;\n    this._calcDimNameToIdx = createHashMap();\n  }\n  /**\n   * Initialize from data\n   */\n\n\n  DataStore.prototype.initData = function (provider, inputDimensions, dimValueGetter) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(isFunction(provider.getItem) && isFunction(provider.count), 'Invalid data provider.');\n    }\n\n    this._provider = provider; // Clear\n\n    this._chunks = [];\n    this._indices = null;\n    this.getRawIndex = this._getRawIdxIdentity;\n    var source = provider.getSource();\n    var defaultGetter = this.defaultDimValueGetter = defaultDimValueGetters[source.sourceFormat]; // Default dim value getter\n\n    this._dimValueGetter = dimValueGetter || defaultGetter; // Reset raw extent.\n\n    this._rawExtent = [];\n    var willRetrieveDataByName = shouldRetrieveDataByName(source);\n    this._dimensions = map(inputDimensions, function (dim) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (willRetrieveDataByName) {\n          assert(dim.property != null);\n        }\n      }\n\n      return {\n        // Only pick these two props. Not leak other properties like orderMeta.\n        type: dim.type,\n        property: dim.property\n      };\n    });\n\n    this._initDataFromProvider(0, provider.count());\n  };\n\n  DataStore.prototype.getProvider = function () {\n    return this._provider;\n  };\n  /**\n   * Caution: even when a `source` instance owned by a series, the created data store\n   * may still be shared by different sereis (the source hash does not use all `source`\n   * props, see `sourceManager`). In this case, the `source` props that are not used in\n   * hash (like `source.dimensionDefine`) probably only belongs to a certain series and\n   * thus should not be fetch here.\n   */\n\n\n  DataStore.prototype.getSource = function () {\n    return this._provider.getSource();\n  };\n  /**\n   * @caution Only used in dataStack.\n   */\n\n\n  DataStore.prototype.ensureCalculationDimension = function (dimName, type) {\n    var calcDimNameToIdx = this._calcDimNameToIdx;\n    var dimensions = this._dimensions;\n    var calcDimIdx = calcDimNameToIdx.get(dimName);\n\n    if (calcDimIdx != null) {\n      if (dimensions[calcDimIdx].type === type) {\n        return calcDimIdx;\n      }\n    } else {\n      calcDimIdx = dimensions.length;\n    }\n\n    dimensions[calcDimIdx] = {\n      type: type\n    };\n    calcDimNameToIdx.set(dimName, calcDimIdx);\n    this._chunks[calcDimIdx] = new dataCtors[type || 'float'](this._rawCount);\n    this._rawExtent[calcDimIdx] = getInitialExtent();\n    return calcDimIdx;\n  };\n\n  DataStore.prototype.collectOrdinalMeta = function (dimIdx, ordinalMeta) {\n    var chunk = this._chunks[dimIdx];\n    var dim = this._dimensions[dimIdx];\n    var rawExtents = this._rawExtent;\n    var offset = dim.ordinalOffset || 0;\n    var len = chunk.length;\n\n    if (offset === 0) {\n      // We need to reset the rawExtent if collect is from start.\n      // Because this dimension may be guessed as number and calcuating a wrong extent.\n      rawExtents[dimIdx] = getInitialExtent();\n    }\n\n    var dimRawExtent = rawExtents[dimIdx]; // Parse from previous data offset. len may be changed after appendData\n\n    for (var i = offset; i < len; i++) {\n      var val = chunk[i] = ordinalMeta.parseAndCollect(chunk[i]);\n\n      if (!isNaN(val)) {\n        dimRawExtent[0] = Math.min(val, dimRawExtent[0]);\n        dimRawExtent[1] = Math.max(val, dimRawExtent[1]);\n      }\n    }\n\n    dim.ordinalMeta = ordinalMeta;\n    dim.ordinalOffset = len;\n    dim.type = 'ordinal'; // Force to be ordinal\n  };\n\n  DataStore.prototype.getOrdinalMeta = function (dimIdx) {\n    var dimInfo = this._dimensions[dimIdx];\n    var ordinalMeta = dimInfo.ordinalMeta;\n    return ordinalMeta;\n  };\n\n  DataStore.prototype.getDimensionProperty = function (dimIndex) {\n    var item = this._dimensions[dimIndex];\n    return item && item.property;\n  };\n  /**\n   * Caution: Can be only called on raw data (before `this._indices` created).\n   */\n\n\n  DataStore.prototype.appendData = function (data) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(!this._indices, 'appendData can only be called on raw data.');\n    }\n\n    var provider = this._provider;\n    var start = this.count();\n    provider.appendData(data);\n    var end = provider.count();\n\n    if (!provider.persistent) {\n      end += start;\n    }\n\n    if (start < end) {\n      this._initDataFromProvider(start, end, true);\n    }\n\n    return [start, end];\n  };\n\n  DataStore.prototype.appendValues = function (values, minFillLen) {\n    var chunks = this._chunks;\n    var dimensions = this._dimensions;\n    var dimLen = dimensions.length;\n    var rawExtent = this._rawExtent;\n    var start = this.count();\n    var end = start + Math.max(values.length, minFillLen || 0);\n\n    for (var i = 0; i < dimLen; i++) {\n      var dim = dimensions[i];\n      prepareStore(chunks, i, dim.type, end, true);\n    }\n\n    var emptyDataItem = [];\n\n    for (var idx = start; idx < end; idx++) {\n      var sourceIdx = idx - start; // Store the data by dimensions\n\n      for (var dimIdx = 0; dimIdx < dimLen; dimIdx++) {\n        var dim = dimensions[dimIdx];\n        var val = defaultDimValueGetters.arrayRows.call(this, values[sourceIdx] || emptyDataItem, dim.property, sourceIdx, dimIdx);\n        chunks[dimIdx][idx] = val;\n        var dimRawExtent = rawExtent[dimIdx];\n        val < dimRawExtent[0] && (dimRawExtent[0] = val);\n        val > dimRawExtent[1] && (dimRawExtent[1] = val);\n      }\n    }\n\n    this._rawCount = this._count = end;\n    return {\n      start: start,\n      end: end\n    };\n  };\n\n  DataStore.prototype._initDataFromProvider = function (start, end, append) {\n    var provider = this._provider;\n    var chunks = this._chunks;\n    var dimensions = this._dimensions;\n    var dimLen = dimensions.length;\n    var rawExtent = this._rawExtent;\n    var dimNames = map(dimensions, function (dim) {\n      return dim.property;\n    });\n\n    for (var i = 0; i < dimLen; i++) {\n      var dim = dimensions[i];\n\n      if (!rawExtent[i]) {\n        rawExtent[i] = getInitialExtent();\n      }\n\n      prepareStore(chunks, i, dim.type, end, append);\n    }\n\n    if (provider.fillStorage) {\n      provider.fillStorage(start, end, chunks, rawExtent);\n    } else {\n      var dataItem = [];\n\n      for (var idx = start; idx < end; idx++) {\n        // NOTICE: Try not to write things into dataItem\n        dataItem = provider.getItem(idx, dataItem); // Each data item is value\n        // [1, 2]\n        // 2\n        // Bar chart, line chart which uses category axis\n        // only gives the 'y' value. 'x' value is the indices of category\n        // Use a tempValue to normalize the value to be a (x, y) value\n        // Store the data by dimensions\n\n        for (var dimIdx = 0; dimIdx < dimLen; dimIdx++) {\n          var dimStorage = chunks[dimIdx]; // PENDING NULL is empty or zero\n\n          var val = this._dimValueGetter(dataItem, dimNames[dimIdx], idx, dimIdx);\n\n          dimStorage[idx] = val;\n          var dimRawExtent = rawExtent[dimIdx];\n          val < dimRawExtent[0] && (dimRawExtent[0] = val);\n          val > dimRawExtent[1] && (dimRawExtent[1] = val);\n        }\n      }\n    }\n\n    if (!provider.persistent && provider.clean) {\n      // Clean unused data if data source is typed array.\n      provider.clean();\n    }\n\n    this._rawCount = this._count = end; // Reset data extent\n\n    this._extent = [];\n  };\n\n  DataStore.prototype.count = function () {\n    return this._count;\n  };\n  /**\n   * Get value. Return NaN if idx is out of range.\n   */\n\n\n  DataStore.prototype.get = function (dim, idx) {\n    if (!(idx >= 0 && idx < this._count)) {\n      return NaN;\n    }\n\n    var dimStore = this._chunks[dim];\n    return dimStore ? dimStore[this.getRawIndex(idx)] : NaN;\n  };\n\n  DataStore.prototype.getValues = function (dimensions, idx) {\n    var values = [];\n    var dimArr = [];\n\n    if (idx == null) {\n      idx = dimensions; // TODO get all from store?\n\n      dimensions = []; // All dimensions\n\n      for (var i = 0; i < this._dimensions.length; i++) {\n        dimArr.push(i);\n      }\n    } else {\n      dimArr = dimensions;\n    }\n\n    for (var i = 0, len = dimArr.length; i < len; i++) {\n      values.push(this.get(dimArr[i], idx));\n    }\n\n    return values;\n  };\n  /**\n   * @param dim concrete dim\n   */\n\n\n  DataStore.prototype.getByRawIndex = function (dim, rawIdx) {\n    if (!(rawIdx >= 0 && rawIdx < this._rawCount)) {\n      return NaN;\n    }\n\n    var dimStore = this._chunks[dim];\n    return dimStore ? dimStore[rawIdx] : NaN;\n  };\n  /**\n   * Get sum of data in one dimension\n   */\n\n\n  DataStore.prototype.getSum = function (dim) {\n    var dimData = this._chunks[dim];\n    var sum = 0;\n\n    if (dimData) {\n      for (var i = 0, len = this.count(); i < len; i++) {\n        var value = this.get(dim, i);\n\n        if (!isNaN(value)) {\n          sum += value;\n        }\n      }\n    }\n\n    return sum;\n  };\n  /**\n   * Get median of data in one dimension\n   */\n\n\n  DataStore.prototype.getMedian = function (dim) {\n    var dimDataArray = []; // map all data of one dimension\n\n    this.each([dim], function (val) {\n      if (!isNaN(val)) {\n        dimDataArray.push(val);\n      }\n    }); // TODO\n    // Use quick select?\n\n    var sortedDimDataArray = dimDataArray.sort(function (a, b) {\n      return a - b;\n    });\n    var len = this.count(); // calculate median\n\n    return len === 0 ? 0 : len % 2 === 1 ? sortedDimDataArray[(len - 1) / 2] : (sortedDimDataArray[len / 2] + sortedDimDataArray[len / 2 - 1]) / 2;\n  };\n  /**\n   * Retreive the index with given raw data index\n   */\n\n\n  DataStore.prototype.indexOfRawIndex = function (rawIndex) {\n    if (rawIndex >= this._rawCount || rawIndex < 0) {\n      return -1;\n    }\n\n    if (!this._indices) {\n      return rawIndex;\n    } // Indices are ascending\n\n\n    var indices = this._indices; // If rawIndex === dataIndex\n\n    var rawDataIndex = indices[rawIndex];\n\n    if (rawDataIndex != null && rawDataIndex < this._count && rawDataIndex === rawIndex) {\n      return rawIndex;\n    }\n\n    var left = 0;\n    var right = this._count - 1;\n\n    while (left <= right) {\n      var mid = (left + right) / 2 | 0;\n\n      if (indices[mid] < rawIndex) {\n        left = mid + 1;\n      } else if (indices[mid] > rawIndex) {\n        right = mid - 1;\n      } else {\n        return mid;\n      }\n    }\n\n    return -1;\n  };\n  /**\n   * Retreive the index of nearest value\n   * @param dim\n   * @param value\n   * @param [maxDistance=Infinity]\n   * @return If and only if multiple indices has\n   *         the same value, they are put to the result.\n   */\n\n\n  DataStore.prototype.indicesOfNearest = function (dim, value, maxDistance) {\n    var chunks = this._chunks;\n    var dimData = chunks[dim];\n    var nearestIndices = [];\n\n    if (!dimData) {\n      return nearestIndices;\n    }\n\n    if (maxDistance == null) {\n      maxDistance = Infinity;\n    }\n\n    var minDist = Infinity;\n    var minDiff = -1;\n    var nearestIndicesLen = 0; // Check the test case of `test/ut/spec/data/SeriesData.js`.\n\n    for (var i = 0, len = this.count(); i < len; i++) {\n      var dataIndex = this.getRawIndex(i);\n      var diff = value - dimData[dataIndex];\n      var dist = Math.abs(diff);\n\n      if (dist <= maxDistance) {\n        // When the `value` is at the middle of `this.get(dim, i)` and `this.get(dim, i+1)`,\n        // we'd better not push both of them to `nearestIndices`, otherwise it is easy to\n        // get more than one item in `nearestIndices` (more specifically, in `tooltip`).\n        // So we chose the one that `diff >= 0` in this csae.\n        // But if `this.get(dim, i)` and `this.get(dim, j)` get the same value, both of them\n        // should be push to `nearestIndices`.\n        if (dist < minDist || dist === minDist && diff >= 0 && minDiff < 0) {\n          minDist = dist;\n          minDiff = diff;\n          nearestIndicesLen = 0;\n        }\n\n        if (diff === minDiff) {\n          nearestIndices[nearestIndicesLen++] = i;\n        }\n      }\n    }\n\n    nearestIndices.length = nearestIndicesLen;\n    return nearestIndices;\n  };\n\n  DataStore.prototype.getIndices = function () {\n    var newIndices;\n    var indices = this._indices;\n\n    if (indices) {\n      var Ctor = indices.constructor;\n      var thisCount = this._count; // `new Array(a, b, c)` is different from `new Uint32Array(a, b, c)`.\n\n      if (Ctor === Array) {\n        newIndices = new Ctor(thisCount);\n\n        for (var i = 0; i < thisCount; i++) {\n          newIndices[i] = indices[i];\n        }\n      } else {\n        newIndices = new Ctor(indices.buffer, 0, thisCount);\n      }\n    } else {\n      var Ctor = getIndicesCtor(this._rawCount);\n      newIndices = new Ctor(this.count());\n\n      for (var i = 0; i < newIndices.length; i++) {\n        newIndices[i] = i;\n      }\n    }\n\n    return newIndices;\n  };\n  /**\n   * Data filter.\n   */\n\n\n  DataStore.prototype.filter = function (dims, cb) {\n    if (!this._count) {\n      return this;\n    }\n\n    var newStore = this.clone();\n    var count = newStore.count();\n    var Ctor = getIndicesCtor(newStore._rawCount);\n    var newIndices = new Ctor(count);\n    var value = [];\n    var dimSize = dims.length;\n    var offset = 0;\n    var dim0 = dims[0];\n    var chunks = newStore._chunks;\n\n    for (var i = 0; i < count; i++) {\n      var keep = void 0;\n      var rawIdx = newStore.getRawIndex(i); // Simple optimization\n\n      if (dimSize === 0) {\n        keep = cb(i);\n      } else if (dimSize === 1) {\n        var val = chunks[dim0][rawIdx];\n        keep = cb(val, i);\n      } else {\n        var k = 0;\n\n        for (; k < dimSize; k++) {\n          value[k] = chunks[dims[k]][rawIdx];\n        }\n\n        value[k] = i;\n        keep = cb.apply(null, value);\n      }\n\n      if (keep) {\n        newIndices[offset++] = rawIdx;\n      }\n    } // Set indices after filtered.\n\n\n    if (offset < count) {\n      newStore._indices = newIndices;\n    }\n\n    newStore._count = offset; // Reset data extent\n\n    newStore._extent = [];\n\n    newStore._updateGetRawIdx();\n\n    return newStore;\n  };\n  /**\n   * Select data in range. (For optimization of filter)\n   * (Manually inline code, support 5 million data filtering in data zoom.)\n   */\n\n\n  DataStore.prototype.selectRange = function (range) {\n    var newStore = this.clone();\n    var len = newStore._count;\n\n    if (!len) {\n      return this;\n    }\n\n    var dims = keys(range);\n    var dimSize = dims.length;\n\n    if (!dimSize) {\n      return this;\n    }\n\n    var originalCount = newStore.count();\n    var Ctor = getIndicesCtor(newStore._rawCount);\n    var newIndices = new Ctor(originalCount);\n    var offset = 0;\n    var dim0 = dims[0];\n    var min = range[dim0][0];\n    var max = range[dim0][1];\n    var storeArr = newStore._chunks;\n    var quickFinished = false;\n\n    if (!newStore._indices) {\n      // Extreme optimization for common case. About 2x faster in chrome.\n      var idx = 0;\n\n      if (dimSize === 1) {\n        var dimStorage = storeArr[dims[0]];\n\n        for (var i = 0; i < len; i++) {\n          var val = dimStorage[i]; // NaN will not be filtered. Consider the case, in line chart, empty\n          // value indicates the line should be broken. But for the case like\n          // scatter plot, a data item with empty value will not be rendered,\n          // but the axis extent may be effected if some other dim of the data\n          // item has value. Fortunately it is not a significant negative effect.\n\n          if (val >= min && val <= max || isNaN(val)) {\n            newIndices[offset++] = idx;\n          }\n\n          idx++;\n        }\n\n        quickFinished = true;\n      } else if (dimSize === 2) {\n        var dimStorage = storeArr[dims[0]];\n        var dimStorage2 = storeArr[dims[1]];\n        var min2 = range[dims[1]][0];\n        var max2 = range[dims[1]][1];\n\n        for (var i = 0; i < len; i++) {\n          var val = dimStorage[i];\n          var val2 = dimStorage2[i]; // Do not filter NaN, see comment above.\n\n          if ((val >= min && val <= max || isNaN(val)) && (val2 >= min2 && val2 <= max2 || isNaN(val2))) {\n            newIndices[offset++] = idx;\n          }\n\n          idx++;\n        }\n\n        quickFinished = true;\n      }\n    }\n\n    if (!quickFinished) {\n      if (dimSize === 1) {\n        for (var i = 0; i < originalCount; i++) {\n          var rawIndex = newStore.getRawIndex(i);\n          var val = storeArr[dims[0]][rawIndex]; // Do not filter NaN, see comment above.\n\n          if (val >= min && val <= max || isNaN(val)) {\n            newIndices[offset++] = rawIndex;\n          }\n        }\n      } else {\n        for (var i = 0; i < originalCount; i++) {\n          var keep = true;\n          var rawIndex = newStore.getRawIndex(i);\n\n          for (var k = 0; k < dimSize; k++) {\n            var dimk = dims[k];\n            var val = storeArr[dimk][rawIndex]; // Do not filter NaN, see comment above.\n\n            if (val < range[dimk][0] || val > range[dimk][1]) {\n              keep = false;\n            }\n          }\n\n          if (keep) {\n            newIndices[offset++] = newStore.getRawIndex(i);\n          }\n        }\n      }\n    } // Set indices after filtered.\n\n\n    if (offset < originalCount) {\n      newStore._indices = newIndices;\n    }\n\n    newStore._count = offset; // Reset data extent\n\n    newStore._extent = [];\n\n    newStore._updateGetRawIdx();\n\n    return newStore;\n  }; // /**\n  //  * Data mapping to a plain array\n  //  */\n  // mapArray(dims: DimensionIndex[], cb: MapArrayCb): any[] {\n  //     const result: any[] = [];\n  //     this.each(dims, function () {\n  //         result.push(cb && (cb as MapArrayCb).apply(null, arguments));\n  //     });\n  //     return result;\n  // }\n\n  /**\n   * Data mapping to a new List with given dimensions\n   */\n\n\n  DataStore.prototype.map = function (dims, cb) {\n    // TODO only clone picked chunks.\n    var target = this.clone(dims);\n\n    this._updateDims(target, dims, cb);\n\n    return target;\n  };\n  /**\n   * @caution Danger!! Only used in dataStack.\n   */\n\n\n  DataStore.prototype.modify = function (dims, cb) {\n    this._updateDims(this, dims, cb);\n  };\n\n  DataStore.prototype._updateDims = function (target, dims, cb) {\n    var targetChunks = target._chunks;\n    var tmpRetValue = [];\n    var dimSize = dims.length;\n    var dataCount = target.count();\n    var values = [];\n    var rawExtent = target._rawExtent;\n\n    for (var i = 0; i < dims.length; i++) {\n      rawExtent[dims[i]] = getInitialExtent();\n    }\n\n    for (var dataIndex = 0; dataIndex < dataCount; dataIndex++) {\n      var rawIndex = target.getRawIndex(dataIndex);\n\n      for (var k = 0; k < dimSize; k++) {\n        values[k] = targetChunks[dims[k]][rawIndex];\n      }\n\n      values[dimSize] = dataIndex;\n      var retValue = cb && cb.apply(null, values);\n\n      if (retValue != null) {\n        // a number or string (in oridinal dimension)?\n        if (typeof retValue !== 'object') {\n          tmpRetValue[0] = retValue;\n          retValue = tmpRetValue;\n        }\n\n        for (var i = 0; i < retValue.length; i++) {\n          var dim = dims[i];\n          var val = retValue[i];\n          var rawExtentOnDim = rawExtent[dim];\n          var dimStore = targetChunks[dim];\n\n          if (dimStore) {\n            dimStore[rawIndex] = val;\n          }\n\n          if (val < rawExtentOnDim[0]) {\n            rawExtentOnDim[0] = val;\n          }\n\n          if (val > rawExtentOnDim[1]) {\n            rawExtentOnDim[1] = val;\n          }\n        }\n      }\n    }\n  };\n  /**\n   * Large data down sampling using largest-triangle-three-buckets\n   * @param {string} valueDimension\n   * @param {number} targetCount\n   */\n\n\n  DataStore.prototype.lttbDownSample = function (valueDimension, rate) {\n    var target = this.clone([valueDimension], true);\n    var targetStorage = target._chunks;\n    var dimStore = targetStorage[valueDimension];\n    var len = this.count();\n    var sampledIndex = 0;\n    var frameSize = Math.floor(1 / rate);\n    var currentRawIndex = this.getRawIndex(0);\n    var maxArea;\n    var area;\n    var nextRawIndex;\n    var newIndices = new (getIndicesCtor(this._rawCount))(Math.min((Math.ceil(len / frameSize) + 2) * 2, len)); // First frame use the first data.\n\n    newIndices[sampledIndex++] = currentRawIndex;\n\n    for (var i = 1; i < len - 1; i += frameSize) {\n      var nextFrameStart = Math.min(i + frameSize, len - 1);\n      var nextFrameEnd = Math.min(i + frameSize * 2, len);\n      var avgX = (nextFrameEnd + nextFrameStart) / 2;\n      var avgY = 0;\n\n      for (var idx = nextFrameStart; idx < nextFrameEnd; idx++) {\n        var rawIndex = this.getRawIndex(idx);\n        var y = dimStore[rawIndex];\n\n        if (isNaN(y)) {\n          continue;\n        }\n\n        avgY += y;\n      }\n\n      avgY /= nextFrameEnd - nextFrameStart;\n      var frameStart = i;\n      var frameEnd = Math.min(i + frameSize, len);\n      var pointAX = i - 1;\n      var pointAY = dimStore[currentRawIndex];\n      maxArea = -1;\n      nextRawIndex = frameStart;\n      var firstNaNIndex = -1;\n      var countNaN = 0; // Find a point from current frame that construct a triangel with largest area with previous selected point\n      // And the average of next frame.\n\n      for (var idx = frameStart; idx < frameEnd; idx++) {\n        var rawIndex = this.getRawIndex(idx);\n        var y = dimStore[rawIndex];\n\n        if (isNaN(y)) {\n          countNaN++;\n\n          if (firstNaNIndex < 0) {\n            firstNaNIndex = rawIndex;\n          }\n\n          continue;\n        } // Calculate triangle area over three buckets\n\n\n        area = Math.abs((pointAX - avgX) * (y - pointAY) - (pointAX - idx) * (avgY - pointAY));\n\n        if (area > maxArea) {\n          maxArea = area;\n          nextRawIndex = rawIndex; // Next a is this b\n        }\n      }\n\n      if (countNaN > 0 && countNaN < frameEnd - frameStart) {\n        // Append first NaN point in every bucket.\n        // It is necessary to ensure the correct order of indices.\n        newIndices[sampledIndex++] = Math.min(firstNaNIndex, nextRawIndex);\n        nextRawIndex = Math.max(firstNaNIndex, nextRawIndex);\n      }\n\n      newIndices[sampledIndex++] = nextRawIndex;\n      currentRawIndex = nextRawIndex; // This a is the next a (chosen b)\n    } // First frame use the last data.\n\n\n    newIndices[sampledIndex++] = this.getRawIndex(len - 1);\n    target._count = sampledIndex;\n    target._indices = newIndices;\n    target.getRawIndex = this._getRawIdx;\n    return target;\n  };\n  /**\n   * Large data down sampling on given dimension\n   * @param sampleIndex Sample index for name and id\n   */\n\n\n  DataStore.prototype.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n    var target = this.clone([dimension], true);\n    var targetStorage = target._chunks;\n    var frameValues = [];\n    var frameSize = Math.floor(1 / rate);\n    var dimStore = targetStorage[dimension];\n    var len = this.count();\n    var rawExtentOnDim = target._rawExtent[dimension] = getInitialExtent();\n    var newIndices = new (getIndicesCtor(this._rawCount))(Math.ceil(len / frameSize));\n    var offset = 0;\n\n    for (var i = 0; i < len; i += frameSize) {\n      // Last frame\n      if (frameSize > len - i) {\n        frameSize = len - i;\n        frameValues.length = frameSize;\n      }\n\n      for (var k = 0; k < frameSize; k++) {\n        var dataIdx = this.getRawIndex(i + k);\n        frameValues[k] = dimStore[dataIdx];\n      }\n\n      var value = sampleValue(frameValues);\n      var sampleFrameIdx = this.getRawIndex(Math.min(i + sampleIndex(frameValues, value) || 0, len - 1)); // Only write value on the filtered data\n\n      dimStore[sampleFrameIdx] = value;\n\n      if (value < rawExtentOnDim[0]) {\n        rawExtentOnDim[0] = value;\n      }\n\n      if (value > rawExtentOnDim[1]) {\n        rawExtentOnDim[1] = value;\n      }\n\n      newIndices[offset++] = sampleFrameIdx;\n    }\n\n    target._count = offset;\n    target._indices = newIndices;\n\n    target._updateGetRawIdx();\n\n    return target;\n  };\n  /**\n   * Data iteration\n   * @param ctx default this\n   * @example\n   *  list.each('x', function (x, idx) {});\n   *  list.each(['x', 'y'], function (x, y, idx) {});\n   *  list.each(function (idx) {})\n   */\n\n\n  DataStore.prototype.each = function (dims, cb) {\n    if (!this._count) {\n      return;\n    }\n\n    var dimSize = dims.length;\n    var chunks = this._chunks;\n\n    for (var i = 0, len = this.count(); i < len; i++) {\n      var rawIdx = this.getRawIndex(i); // Simple optimization\n\n      switch (dimSize) {\n        case 0:\n          cb(i);\n          break;\n\n        case 1:\n          cb(chunks[dims[0]][rawIdx], i);\n          break;\n\n        case 2:\n          cb(chunks[dims[0]][rawIdx], chunks[dims[1]][rawIdx], i);\n          break;\n\n        default:\n          var k = 0;\n          var value = [];\n\n          for (; k < dimSize; k++) {\n            value[k] = chunks[dims[k]][rawIdx];\n          } // Index\n\n\n          value[k] = i;\n          cb.apply(null, value);\n      }\n    }\n  };\n  /**\n   * Get extent of data in one dimension\n   */\n\n\n  DataStore.prototype.getDataExtent = function (dim) {\n    // Make sure use concrete dim as cache name.\n    var dimData = this._chunks[dim];\n    var initialExtent = getInitialExtent();\n\n    if (!dimData) {\n      return initialExtent;\n    } // Make more strict checkings to ensure hitting cache.\n\n\n    var currEnd = this.count(); // Consider the most cases when using data zoom, `getDataExtent`\n    // happened before filtering. We cache raw extent, which is not\n    // necessary to be cleared and recalculated when restore data.\n\n    var useRaw = !this._indices;\n    var dimExtent;\n\n    if (useRaw) {\n      return this._rawExtent[dim].slice();\n    }\n\n    dimExtent = this._extent[dim];\n\n    if (dimExtent) {\n      return dimExtent.slice();\n    }\n\n    dimExtent = initialExtent;\n    var min = dimExtent[0];\n    var max = dimExtent[1];\n\n    for (var i = 0; i < currEnd; i++) {\n      var rawIdx = this.getRawIndex(i);\n      var value = dimData[rawIdx];\n      value < min && (min = value);\n      value > max && (max = value);\n    }\n\n    dimExtent = [min, max];\n    this._extent[dim] = dimExtent;\n    return dimExtent;\n  };\n  /**\n   * Get raw data item\n   */\n\n\n  DataStore.prototype.getRawDataItem = function (idx) {\n    var rawIdx = this.getRawIndex(idx);\n\n    if (!this._provider.persistent) {\n      var val = [];\n      var chunks = this._chunks;\n\n      for (var i = 0; i < chunks.length; i++) {\n        val.push(chunks[i][rawIdx]);\n      }\n\n      return val;\n    } else {\n      return this._provider.getItem(rawIdx);\n    }\n  };\n  /**\n   * Clone shallow.\n   *\n   * @param clonedDims Determine which dims to clone. Will share the data if not specified.\n   */\n\n\n  DataStore.prototype.clone = function (clonedDims, ignoreIndices) {\n    var target = new DataStore();\n    var chunks = this._chunks;\n    var clonedDimsMap = clonedDims && reduce(clonedDims, function (obj, dimIdx) {\n      obj[dimIdx] = true;\n      return obj;\n    }, {});\n\n    if (clonedDimsMap) {\n      for (var i = 0; i < chunks.length; i++) {\n        // Not clone if dim is not picked.\n        target._chunks[i] = !clonedDimsMap[i] ? chunks[i] : cloneChunk(chunks[i]);\n      }\n    } else {\n      target._chunks = chunks;\n    }\n\n    this._copyCommonProps(target);\n\n    if (!ignoreIndices) {\n      target._indices = this._cloneIndices();\n    }\n\n    target._updateGetRawIdx();\n\n    return target;\n  };\n\n  DataStore.prototype._copyCommonProps = function (target) {\n    target._count = this._count;\n    target._rawCount = this._rawCount;\n    target._provider = this._provider;\n    target._dimensions = this._dimensions;\n    target._extent = clone(this._extent);\n    target._rawExtent = clone(this._rawExtent);\n  };\n\n  DataStore.prototype._cloneIndices = function () {\n    if (this._indices) {\n      var Ctor = this._indices.constructor;\n      var indices = void 0;\n\n      if (Ctor === Array) {\n        var thisCount = this._indices.length;\n        indices = new Ctor(thisCount);\n\n        for (var i = 0; i < thisCount; i++) {\n          indices[i] = this._indices[i];\n        }\n      } else {\n        indices = new Ctor(this._indices);\n      }\n\n      return indices;\n    }\n\n    return null;\n  };\n\n  DataStore.prototype._getRawIdxIdentity = function (idx) {\n    return idx;\n  };\n\n  DataStore.prototype._getRawIdx = function (idx) {\n    if (idx < this._count && idx >= 0) {\n      return this._indices[idx];\n    }\n\n    return -1;\n  };\n\n  DataStore.prototype._updateGetRawIdx = function () {\n    this.getRawIndex = this._indices ? this._getRawIdx : this._getRawIdxIdentity;\n  };\n\n  DataStore.internalField = function () {\n    function getDimValueSimply(dataItem, property, dataIndex, dimIndex) {\n      return parseDataValue(dataItem[dimIndex], this._dimensions[dimIndex]);\n    }\n\n    defaultDimValueGetters = {\n      arrayRows: getDimValueSimply,\n      objectRows: function (dataItem, property, dataIndex, dimIndex) {\n        return parseDataValue(dataItem[property], this._dimensions[dimIndex]);\n      },\n      keyedColumns: getDimValueSimply,\n      original: function (dataItem, property, dataIndex, dimIndex) {\n        // Performance sensitive, do not use modelUtil.getDataItemValue.\n        // If dataItem is an plain object with no value field, the let `value`\n        // will be assigned with the object, but it will be tread correctly\n        // in the `convertValue`.\n        var value = dataItem && (dataItem.value == null ? dataItem : dataItem.value);\n        return parseDataValue(value instanceof Array ? value[dimIndex] // If value is a single number or something else not array.\n        : value, this._dimensions[dimIndex]);\n      },\n      typedArray: function (dataItem, property, dataIndex, dimIndex) {\n        return dataItem[dimIndex];\n      }\n    };\n  }();\n\n  return DataStore;\n}();\n\nexport default DataStore;","map":{"version":3,"names":["assert","clone","createHashMap","isFunction","keys","map","reduce","parseDataValue","shouldRetrieveDataByName","UNDEFINED","CtorUint32Array","Uint32Array","Array","CtorUint16Array","Uint16Array","CtorInt32Array","Int32Array","CtorFloat64Array","Float64Array","dataCtors","defaultDimValueGetters","getIndicesCtor","rawCount","getInitialExtent","Infinity","cloneChunk","originalChunk","Ctor","constructor","slice","prepareStore","store","dimIdx","dimType","end","append","DataCtor","oldStore","oldLen","length","newStore","j","DataStore","_chunks","_rawExtent","_extent","_count","_rawCount","_calcDimNameToIdx","prototype","initData","provider","inputDimensions","dimValueGetter","process","env","NODE_ENV","getItem","count","_provider","_indices","getRawIndex","_getRawIdxIdentity","source","getSource","defaultGetter","defaultDimValueGetter","sourceFormat","_dimValueGetter","willRetrieveDataByName","_dimensions","dim","property","type","_initDataFromProvider","getProvider","ensureCalculationDimension","dimName","calcDimNameToIdx","dimensions","calcDimIdx","get","set","collectOrdinalMeta","ordinalMeta","chunk","rawExtents","offset","ordinalOffset","len","dimRawExtent","i","val","parseAndCollect","isNaN","Math","min","max","getOrdinalMeta","dimInfo","getDimensionProperty","dimIndex","item","appendData","data","start","persistent","appendValues","values","minFillLen","chunks","dimLen","rawExtent","emptyDataItem","idx","sourceIdx","arrayRows","call","dimNames","fillStorage","dataItem","dimStorage","clean","NaN","dimStore","getValues","dimArr","push","getByRawIndex","rawIdx","getSum","dimData","sum","value","getMedian","dimDataArray","each","sortedDimDataArray","sort","a","b","indexOfRawIndex","rawIndex","indices","rawDataIndex","left","right","mid","indicesOfNearest","maxDistance","nearestIndices","minDist","minDiff","nearestIndicesLen","dataIndex","diff","dist","abs","getIndices","newIndices","thisCount","buffer","filter","dims","cb","dimSize","dim0","keep","k","apply","_updateGetRawIdx","selectRange","range","originalCount","storeArr","quickFinished","dimStorage2","min2","max2","val2","dimk","target","_updateDims","modify","targetChunks","tmpRetValue","dataCount","retValue","rawExtentOnDim","lttbDownSample","valueDimension","rate","targetStorage","sampledIndex","frameSize","floor","currentRawIndex","maxArea","area","nextRawIndex","ceil","nextFrameStart","nextFrameEnd","avgX","avgY","y","frameStart","frameEnd","pointAX","pointAY","firstNaNIndex","countNaN","_getRawIdx","downSample","dimension","sampleValue","sampleIndex","frameValues","dataIdx","sampleFrameIdx","getDataExtent","initialExtent","currEnd","useRaw","dimExtent","getRawDataItem","clonedDims","ignoreIndices","clonedDimsMap","obj","_copyCommonProps","_cloneIndices","internalField","getDimValueSimply","objectRows","keyedColumns","original","typedArray"],"sources":["D:/springboot+vue框架/yiqing/yq-vue/node_modules/echarts/lib/data/DataStore.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { assert, clone, createHashMap, isFunction, keys, map, reduce } from 'zrender/lib/core/util.js';\nimport { parseDataValue } from './helper/dataValueHelper.js';\nimport { shouldRetrieveDataByName } from './Source.js';\nvar UNDEFINED = 'undefined';\n/* global Float64Array, Int32Array, Uint32Array, Uint16Array */\n// Caution: MUST not use `new CtorUint32Array(arr, 0, len)`, because the Ctor of array is\n// different from the Ctor of typed array.\n\nexport var CtorUint32Array = typeof Uint32Array === UNDEFINED ? Array : Uint32Array;\nexport var CtorUint16Array = typeof Uint16Array === UNDEFINED ? Array : Uint16Array;\nexport var CtorInt32Array = typeof Int32Array === UNDEFINED ? Array : Int32Array;\nexport var CtorFloat64Array = typeof Float64Array === UNDEFINED ? Array : Float64Array;\n/**\n * Multi dimensional data store\n */\n\nvar dataCtors = {\n  'float': CtorFloat64Array,\n  'int': CtorInt32Array,\n  // Ordinal data type can be string or int\n  'ordinal': Array,\n  'number': Array,\n  'time': CtorFloat64Array\n};\nvar defaultDimValueGetters;\n\nfunction getIndicesCtor(rawCount) {\n  // The possible max value in this._indicies is always this._rawCount despite of filtering.\n  return rawCount > 65535 ? CtorUint32Array : CtorUint16Array;\n}\n\n;\n\nfunction getInitialExtent() {\n  return [Infinity, -Infinity];\n}\n\n;\n\nfunction cloneChunk(originalChunk) {\n  var Ctor = originalChunk.constructor; // Only shallow clone is enough when Array.\n\n  return Ctor === Array ? originalChunk.slice() : new Ctor(originalChunk);\n}\n\nfunction prepareStore(store, dimIdx, dimType, end, append) {\n  var DataCtor = dataCtors[dimType || 'float'];\n\n  if (append) {\n    var oldStore = store[dimIdx];\n    var oldLen = oldStore && oldStore.length;\n\n    if (!(oldLen === end)) {\n      var newStore = new DataCtor(end); // The cost of the copy is probably inconsiderable\n      // within the initial chunkSize.\n\n      for (var j = 0; j < oldLen; j++) {\n        newStore[j] = oldStore[j];\n      }\n\n      store[dimIdx] = newStore;\n    }\n  } else {\n    store[dimIdx] = new DataCtor(end);\n  }\n}\n\n;\n/**\n * Basically, DataStore API keep immutable.\n */\n\nvar DataStore =\n/** @class */\nfunction () {\n  function DataStore() {\n    this._chunks = []; // It will not be calculated util needed.\n\n    this._rawExtent = [];\n    this._extent = [];\n    this._count = 0;\n    this._rawCount = 0;\n    this._calcDimNameToIdx = createHashMap();\n  }\n  /**\n   * Initialize from data\n   */\n\n\n  DataStore.prototype.initData = function (provider, inputDimensions, dimValueGetter) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(isFunction(provider.getItem) && isFunction(provider.count), 'Invalid data provider.');\n    }\n\n    this._provider = provider; // Clear\n\n    this._chunks = [];\n    this._indices = null;\n    this.getRawIndex = this._getRawIdxIdentity;\n    var source = provider.getSource();\n    var defaultGetter = this.defaultDimValueGetter = defaultDimValueGetters[source.sourceFormat]; // Default dim value getter\n\n    this._dimValueGetter = dimValueGetter || defaultGetter; // Reset raw extent.\n\n    this._rawExtent = [];\n    var willRetrieveDataByName = shouldRetrieveDataByName(source);\n    this._dimensions = map(inputDimensions, function (dim) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (willRetrieveDataByName) {\n          assert(dim.property != null);\n        }\n      }\n\n      return {\n        // Only pick these two props. Not leak other properties like orderMeta.\n        type: dim.type,\n        property: dim.property\n      };\n    });\n\n    this._initDataFromProvider(0, provider.count());\n  };\n\n  DataStore.prototype.getProvider = function () {\n    return this._provider;\n  };\n  /**\n   * Caution: even when a `source` instance owned by a series, the created data store\n   * may still be shared by different sereis (the source hash does not use all `source`\n   * props, see `sourceManager`). In this case, the `source` props that are not used in\n   * hash (like `source.dimensionDefine`) probably only belongs to a certain series and\n   * thus should not be fetch here.\n   */\n\n\n  DataStore.prototype.getSource = function () {\n    return this._provider.getSource();\n  };\n  /**\n   * @caution Only used in dataStack.\n   */\n\n\n  DataStore.prototype.ensureCalculationDimension = function (dimName, type) {\n    var calcDimNameToIdx = this._calcDimNameToIdx;\n    var dimensions = this._dimensions;\n    var calcDimIdx = calcDimNameToIdx.get(dimName);\n\n    if (calcDimIdx != null) {\n      if (dimensions[calcDimIdx].type === type) {\n        return calcDimIdx;\n      }\n    } else {\n      calcDimIdx = dimensions.length;\n    }\n\n    dimensions[calcDimIdx] = {\n      type: type\n    };\n    calcDimNameToIdx.set(dimName, calcDimIdx);\n    this._chunks[calcDimIdx] = new dataCtors[type || 'float'](this._rawCount);\n    this._rawExtent[calcDimIdx] = getInitialExtent();\n    return calcDimIdx;\n  };\n\n  DataStore.prototype.collectOrdinalMeta = function (dimIdx, ordinalMeta) {\n    var chunk = this._chunks[dimIdx];\n    var dim = this._dimensions[dimIdx];\n    var rawExtents = this._rawExtent;\n    var offset = dim.ordinalOffset || 0;\n    var len = chunk.length;\n\n    if (offset === 0) {\n      // We need to reset the rawExtent if collect is from start.\n      // Because this dimension may be guessed as number and calcuating a wrong extent.\n      rawExtents[dimIdx] = getInitialExtent();\n    }\n\n    var dimRawExtent = rawExtents[dimIdx]; // Parse from previous data offset. len may be changed after appendData\n\n    for (var i = offset; i < len; i++) {\n      var val = chunk[i] = ordinalMeta.parseAndCollect(chunk[i]);\n\n      if (!isNaN(val)) {\n        dimRawExtent[0] = Math.min(val, dimRawExtent[0]);\n        dimRawExtent[1] = Math.max(val, dimRawExtent[1]);\n      }\n    }\n\n    dim.ordinalMeta = ordinalMeta;\n    dim.ordinalOffset = len;\n    dim.type = 'ordinal'; // Force to be ordinal\n  };\n\n  DataStore.prototype.getOrdinalMeta = function (dimIdx) {\n    var dimInfo = this._dimensions[dimIdx];\n    var ordinalMeta = dimInfo.ordinalMeta;\n    return ordinalMeta;\n  };\n\n  DataStore.prototype.getDimensionProperty = function (dimIndex) {\n    var item = this._dimensions[dimIndex];\n    return item && item.property;\n  };\n  /**\n   * Caution: Can be only called on raw data (before `this._indices` created).\n   */\n\n\n  DataStore.prototype.appendData = function (data) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(!this._indices, 'appendData can only be called on raw data.');\n    }\n\n    var provider = this._provider;\n    var start = this.count();\n    provider.appendData(data);\n    var end = provider.count();\n\n    if (!provider.persistent) {\n      end += start;\n    }\n\n    if (start < end) {\n      this._initDataFromProvider(start, end, true);\n    }\n\n    return [start, end];\n  };\n\n  DataStore.prototype.appendValues = function (values, minFillLen) {\n    var chunks = this._chunks;\n    var dimensions = this._dimensions;\n    var dimLen = dimensions.length;\n    var rawExtent = this._rawExtent;\n    var start = this.count();\n    var end = start + Math.max(values.length, minFillLen || 0);\n\n    for (var i = 0; i < dimLen; i++) {\n      var dim = dimensions[i];\n      prepareStore(chunks, i, dim.type, end, true);\n    }\n\n    var emptyDataItem = [];\n\n    for (var idx = start; idx < end; idx++) {\n      var sourceIdx = idx - start; // Store the data by dimensions\n\n      for (var dimIdx = 0; dimIdx < dimLen; dimIdx++) {\n        var dim = dimensions[dimIdx];\n        var val = defaultDimValueGetters.arrayRows.call(this, values[sourceIdx] || emptyDataItem, dim.property, sourceIdx, dimIdx);\n        chunks[dimIdx][idx] = val;\n        var dimRawExtent = rawExtent[dimIdx];\n        val < dimRawExtent[0] && (dimRawExtent[0] = val);\n        val > dimRawExtent[1] && (dimRawExtent[1] = val);\n      }\n    }\n\n    this._rawCount = this._count = end;\n    return {\n      start: start,\n      end: end\n    };\n  };\n\n  DataStore.prototype._initDataFromProvider = function (start, end, append) {\n    var provider = this._provider;\n    var chunks = this._chunks;\n    var dimensions = this._dimensions;\n    var dimLen = dimensions.length;\n    var rawExtent = this._rawExtent;\n    var dimNames = map(dimensions, function (dim) {\n      return dim.property;\n    });\n\n    for (var i = 0; i < dimLen; i++) {\n      var dim = dimensions[i];\n\n      if (!rawExtent[i]) {\n        rawExtent[i] = getInitialExtent();\n      }\n\n      prepareStore(chunks, i, dim.type, end, append);\n    }\n\n    if (provider.fillStorage) {\n      provider.fillStorage(start, end, chunks, rawExtent);\n    } else {\n      var dataItem = [];\n\n      for (var idx = start; idx < end; idx++) {\n        // NOTICE: Try not to write things into dataItem\n        dataItem = provider.getItem(idx, dataItem); // Each data item is value\n        // [1, 2]\n        // 2\n        // Bar chart, line chart which uses category axis\n        // only gives the 'y' value. 'x' value is the indices of category\n        // Use a tempValue to normalize the value to be a (x, y) value\n        // Store the data by dimensions\n\n        for (var dimIdx = 0; dimIdx < dimLen; dimIdx++) {\n          var dimStorage = chunks[dimIdx]; // PENDING NULL is empty or zero\n\n          var val = this._dimValueGetter(dataItem, dimNames[dimIdx], idx, dimIdx);\n\n          dimStorage[idx] = val;\n          var dimRawExtent = rawExtent[dimIdx];\n          val < dimRawExtent[0] && (dimRawExtent[0] = val);\n          val > dimRawExtent[1] && (dimRawExtent[1] = val);\n        }\n      }\n    }\n\n    if (!provider.persistent && provider.clean) {\n      // Clean unused data if data source is typed array.\n      provider.clean();\n    }\n\n    this._rawCount = this._count = end; // Reset data extent\n\n    this._extent = [];\n  };\n\n  DataStore.prototype.count = function () {\n    return this._count;\n  };\n  /**\n   * Get value. Return NaN if idx is out of range.\n   */\n\n\n  DataStore.prototype.get = function (dim, idx) {\n    if (!(idx >= 0 && idx < this._count)) {\n      return NaN;\n    }\n\n    var dimStore = this._chunks[dim];\n    return dimStore ? dimStore[this.getRawIndex(idx)] : NaN;\n  };\n\n  DataStore.prototype.getValues = function (dimensions, idx) {\n    var values = [];\n    var dimArr = [];\n\n    if (idx == null) {\n      idx = dimensions; // TODO get all from store?\n\n      dimensions = []; // All dimensions\n\n      for (var i = 0; i < this._dimensions.length; i++) {\n        dimArr.push(i);\n      }\n    } else {\n      dimArr = dimensions;\n    }\n\n    for (var i = 0, len = dimArr.length; i < len; i++) {\n      values.push(this.get(dimArr[i], idx));\n    }\n\n    return values;\n  };\n  /**\n   * @param dim concrete dim\n   */\n\n\n  DataStore.prototype.getByRawIndex = function (dim, rawIdx) {\n    if (!(rawIdx >= 0 && rawIdx < this._rawCount)) {\n      return NaN;\n    }\n\n    var dimStore = this._chunks[dim];\n    return dimStore ? dimStore[rawIdx] : NaN;\n  };\n  /**\n   * Get sum of data in one dimension\n   */\n\n\n  DataStore.prototype.getSum = function (dim) {\n    var dimData = this._chunks[dim];\n    var sum = 0;\n\n    if (dimData) {\n      for (var i = 0, len = this.count(); i < len; i++) {\n        var value = this.get(dim, i);\n\n        if (!isNaN(value)) {\n          sum += value;\n        }\n      }\n    }\n\n    return sum;\n  };\n  /**\n   * Get median of data in one dimension\n   */\n\n\n  DataStore.prototype.getMedian = function (dim) {\n    var dimDataArray = []; // map all data of one dimension\n\n    this.each([dim], function (val) {\n      if (!isNaN(val)) {\n        dimDataArray.push(val);\n      }\n    }); // TODO\n    // Use quick select?\n\n    var sortedDimDataArray = dimDataArray.sort(function (a, b) {\n      return a - b;\n    });\n    var len = this.count(); // calculate median\n\n    return len === 0 ? 0 : len % 2 === 1 ? sortedDimDataArray[(len - 1) / 2] : (sortedDimDataArray[len / 2] + sortedDimDataArray[len / 2 - 1]) / 2;\n  };\n  /**\n   * Retreive the index with given raw data index\n   */\n\n\n  DataStore.prototype.indexOfRawIndex = function (rawIndex) {\n    if (rawIndex >= this._rawCount || rawIndex < 0) {\n      return -1;\n    }\n\n    if (!this._indices) {\n      return rawIndex;\n    } // Indices are ascending\n\n\n    var indices = this._indices; // If rawIndex === dataIndex\n\n    var rawDataIndex = indices[rawIndex];\n\n    if (rawDataIndex != null && rawDataIndex < this._count && rawDataIndex === rawIndex) {\n      return rawIndex;\n    }\n\n    var left = 0;\n    var right = this._count - 1;\n\n    while (left <= right) {\n      var mid = (left + right) / 2 | 0;\n\n      if (indices[mid] < rawIndex) {\n        left = mid + 1;\n      } else if (indices[mid] > rawIndex) {\n        right = mid - 1;\n      } else {\n        return mid;\n      }\n    }\n\n    return -1;\n  };\n  /**\n   * Retreive the index of nearest value\n   * @param dim\n   * @param value\n   * @param [maxDistance=Infinity]\n   * @return If and only if multiple indices has\n   *         the same value, they are put to the result.\n   */\n\n\n  DataStore.prototype.indicesOfNearest = function (dim, value, maxDistance) {\n    var chunks = this._chunks;\n    var dimData = chunks[dim];\n    var nearestIndices = [];\n\n    if (!dimData) {\n      return nearestIndices;\n    }\n\n    if (maxDistance == null) {\n      maxDistance = Infinity;\n    }\n\n    var minDist = Infinity;\n    var minDiff = -1;\n    var nearestIndicesLen = 0; // Check the test case of `test/ut/spec/data/SeriesData.js`.\n\n    for (var i = 0, len = this.count(); i < len; i++) {\n      var dataIndex = this.getRawIndex(i);\n      var diff = value - dimData[dataIndex];\n      var dist = Math.abs(diff);\n\n      if (dist <= maxDistance) {\n        // When the `value` is at the middle of `this.get(dim, i)` and `this.get(dim, i+1)`,\n        // we'd better not push both of them to `nearestIndices`, otherwise it is easy to\n        // get more than one item in `nearestIndices` (more specifically, in `tooltip`).\n        // So we chose the one that `diff >= 0` in this csae.\n        // But if `this.get(dim, i)` and `this.get(dim, j)` get the same value, both of them\n        // should be push to `nearestIndices`.\n        if (dist < minDist || dist === minDist && diff >= 0 && minDiff < 0) {\n          minDist = dist;\n          minDiff = diff;\n          nearestIndicesLen = 0;\n        }\n\n        if (diff === minDiff) {\n          nearestIndices[nearestIndicesLen++] = i;\n        }\n      }\n    }\n\n    nearestIndices.length = nearestIndicesLen;\n    return nearestIndices;\n  };\n\n  DataStore.prototype.getIndices = function () {\n    var newIndices;\n    var indices = this._indices;\n\n    if (indices) {\n      var Ctor = indices.constructor;\n      var thisCount = this._count; // `new Array(a, b, c)` is different from `new Uint32Array(a, b, c)`.\n\n      if (Ctor === Array) {\n        newIndices = new Ctor(thisCount);\n\n        for (var i = 0; i < thisCount; i++) {\n          newIndices[i] = indices[i];\n        }\n      } else {\n        newIndices = new Ctor(indices.buffer, 0, thisCount);\n      }\n    } else {\n      var Ctor = getIndicesCtor(this._rawCount);\n      newIndices = new Ctor(this.count());\n\n      for (var i = 0; i < newIndices.length; i++) {\n        newIndices[i] = i;\n      }\n    }\n\n    return newIndices;\n  };\n  /**\n   * Data filter.\n   */\n\n\n  DataStore.prototype.filter = function (dims, cb) {\n    if (!this._count) {\n      return this;\n    }\n\n    var newStore = this.clone();\n    var count = newStore.count();\n    var Ctor = getIndicesCtor(newStore._rawCount);\n    var newIndices = new Ctor(count);\n    var value = [];\n    var dimSize = dims.length;\n    var offset = 0;\n    var dim0 = dims[0];\n    var chunks = newStore._chunks;\n\n    for (var i = 0; i < count; i++) {\n      var keep = void 0;\n      var rawIdx = newStore.getRawIndex(i); // Simple optimization\n\n      if (dimSize === 0) {\n        keep = cb(i);\n      } else if (dimSize === 1) {\n        var val = chunks[dim0][rawIdx];\n        keep = cb(val, i);\n      } else {\n        var k = 0;\n\n        for (; k < dimSize; k++) {\n          value[k] = chunks[dims[k]][rawIdx];\n        }\n\n        value[k] = i;\n        keep = cb.apply(null, value);\n      }\n\n      if (keep) {\n        newIndices[offset++] = rawIdx;\n      }\n    } // Set indices after filtered.\n\n\n    if (offset < count) {\n      newStore._indices = newIndices;\n    }\n\n    newStore._count = offset; // Reset data extent\n\n    newStore._extent = [];\n\n    newStore._updateGetRawIdx();\n\n    return newStore;\n  };\n  /**\n   * Select data in range. (For optimization of filter)\n   * (Manually inline code, support 5 million data filtering in data zoom.)\n   */\n\n\n  DataStore.prototype.selectRange = function (range) {\n    var newStore = this.clone();\n    var len = newStore._count;\n\n    if (!len) {\n      return this;\n    }\n\n    var dims = keys(range);\n    var dimSize = dims.length;\n\n    if (!dimSize) {\n      return this;\n    }\n\n    var originalCount = newStore.count();\n    var Ctor = getIndicesCtor(newStore._rawCount);\n    var newIndices = new Ctor(originalCount);\n    var offset = 0;\n    var dim0 = dims[0];\n    var min = range[dim0][0];\n    var max = range[dim0][1];\n    var storeArr = newStore._chunks;\n    var quickFinished = false;\n\n    if (!newStore._indices) {\n      // Extreme optimization for common case. About 2x faster in chrome.\n      var idx = 0;\n\n      if (dimSize === 1) {\n        var dimStorage = storeArr[dims[0]];\n\n        for (var i = 0; i < len; i++) {\n          var val = dimStorage[i]; // NaN will not be filtered. Consider the case, in line chart, empty\n          // value indicates the line should be broken. But for the case like\n          // scatter plot, a data item with empty value will not be rendered,\n          // but the axis extent may be effected if some other dim of the data\n          // item has value. Fortunately it is not a significant negative effect.\n\n          if (val >= min && val <= max || isNaN(val)) {\n            newIndices[offset++] = idx;\n          }\n\n          idx++;\n        }\n\n        quickFinished = true;\n      } else if (dimSize === 2) {\n        var dimStorage = storeArr[dims[0]];\n        var dimStorage2 = storeArr[dims[1]];\n        var min2 = range[dims[1]][0];\n        var max2 = range[dims[1]][1];\n\n        for (var i = 0; i < len; i++) {\n          var val = dimStorage[i];\n          var val2 = dimStorage2[i]; // Do not filter NaN, see comment above.\n\n          if ((val >= min && val <= max || isNaN(val)) && (val2 >= min2 && val2 <= max2 || isNaN(val2))) {\n            newIndices[offset++] = idx;\n          }\n\n          idx++;\n        }\n\n        quickFinished = true;\n      }\n    }\n\n    if (!quickFinished) {\n      if (dimSize === 1) {\n        for (var i = 0; i < originalCount; i++) {\n          var rawIndex = newStore.getRawIndex(i);\n          var val = storeArr[dims[0]][rawIndex]; // Do not filter NaN, see comment above.\n\n          if (val >= min && val <= max || isNaN(val)) {\n            newIndices[offset++] = rawIndex;\n          }\n        }\n      } else {\n        for (var i = 0; i < originalCount; i++) {\n          var keep = true;\n          var rawIndex = newStore.getRawIndex(i);\n\n          for (var k = 0; k < dimSize; k++) {\n            var dimk = dims[k];\n            var val = storeArr[dimk][rawIndex]; // Do not filter NaN, see comment above.\n\n            if (val < range[dimk][0] || val > range[dimk][1]) {\n              keep = false;\n            }\n          }\n\n          if (keep) {\n            newIndices[offset++] = newStore.getRawIndex(i);\n          }\n        }\n      }\n    } // Set indices after filtered.\n\n\n    if (offset < originalCount) {\n      newStore._indices = newIndices;\n    }\n\n    newStore._count = offset; // Reset data extent\n\n    newStore._extent = [];\n\n    newStore._updateGetRawIdx();\n\n    return newStore;\n  }; // /**\n  //  * Data mapping to a plain array\n  //  */\n  // mapArray(dims: DimensionIndex[], cb: MapArrayCb): any[] {\n  //     const result: any[] = [];\n  //     this.each(dims, function () {\n  //         result.push(cb && (cb as MapArrayCb).apply(null, arguments));\n  //     });\n  //     return result;\n  // }\n\n  /**\n   * Data mapping to a new List with given dimensions\n   */\n\n\n  DataStore.prototype.map = function (dims, cb) {\n    // TODO only clone picked chunks.\n    var target = this.clone(dims);\n\n    this._updateDims(target, dims, cb);\n\n    return target;\n  };\n  /**\n   * @caution Danger!! Only used in dataStack.\n   */\n\n\n  DataStore.prototype.modify = function (dims, cb) {\n    this._updateDims(this, dims, cb);\n  };\n\n  DataStore.prototype._updateDims = function (target, dims, cb) {\n    var targetChunks = target._chunks;\n    var tmpRetValue = [];\n    var dimSize = dims.length;\n    var dataCount = target.count();\n    var values = [];\n    var rawExtent = target._rawExtent;\n\n    for (var i = 0; i < dims.length; i++) {\n      rawExtent[dims[i]] = getInitialExtent();\n    }\n\n    for (var dataIndex = 0; dataIndex < dataCount; dataIndex++) {\n      var rawIndex = target.getRawIndex(dataIndex);\n\n      for (var k = 0; k < dimSize; k++) {\n        values[k] = targetChunks[dims[k]][rawIndex];\n      }\n\n      values[dimSize] = dataIndex;\n      var retValue = cb && cb.apply(null, values);\n\n      if (retValue != null) {\n        // a number or string (in oridinal dimension)?\n        if (typeof retValue !== 'object') {\n          tmpRetValue[0] = retValue;\n          retValue = tmpRetValue;\n        }\n\n        for (var i = 0; i < retValue.length; i++) {\n          var dim = dims[i];\n          var val = retValue[i];\n          var rawExtentOnDim = rawExtent[dim];\n          var dimStore = targetChunks[dim];\n\n          if (dimStore) {\n            dimStore[rawIndex] = val;\n          }\n\n          if (val < rawExtentOnDim[0]) {\n            rawExtentOnDim[0] = val;\n          }\n\n          if (val > rawExtentOnDim[1]) {\n            rawExtentOnDim[1] = val;\n          }\n        }\n      }\n    }\n  };\n  /**\n   * Large data down sampling using largest-triangle-three-buckets\n   * @param {string} valueDimension\n   * @param {number} targetCount\n   */\n\n\n  DataStore.prototype.lttbDownSample = function (valueDimension, rate) {\n    var target = this.clone([valueDimension], true);\n    var targetStorage = target._chunks;\n    var dimStore = targetStorage[valueDimension];\n    var len = this.count();\n    var sampledIndex = 0;\n    var frameSize = Math.floor(1 / rate);\n    var currentRawIndex = this.getRawIndex(0);\n    var maxArea;\n    var area;\n    var nextRawIndex;\n    var newIndices = new (getIndicesCtor(this._rawCount))(Math.min((Math.ceil(len / frameSize) + 2) * 2, len)); // First frame use the first data.\n\n    newIndices[sampledIndex++] = currentRawIndex;\n\n    for (var i = 1; i < len - 1; i += frameSize) {\n      var nextFrameStart = Math.min(i + frameSize, len - 1);\n      var nextFrameEnd = Math.min(i + frameSize * 2, len);\n      var avgX = (nextFrameEnd + nextFrameStart) / 2;\n      var avgY = 0;\n\n      for (var idx = nextFrameStart; idx < nextFrameEnd; idx++) {\n        var rawIndex = this.getRawIndex(idx);\n        var y = dimStore[rawIndex];\n\n        if (isNaN(y)) {\n          continue;\n        }\n\n        avgY += y;\n      }\n\n      avgY /= nextFrameEnd - nextFrameStart;\n      var frameStart = i;\n      var frameEnd = Math.min(i + frameSize, len);\n      var pointAX = i - 1;\n      var pointAY = dimStore[currentRawIndex];\n      maxArea = -1;\n      nextRawIndex = frameStart;\n      var firstNaNIndex = -1;\n      var countNaN = 0; // Find a point from current frame that construct a triangel with largest area with previous selected point\n      // And the average of next frame.\n\n      for (var idx = frameStart; idx < frameEnd; idx++) {\n        var rawIndex = this.getRawIndex(idx);\n        var y = dimStore[rawIndex];\n\n        if (isNaN(y)) {\n          countNaN++;\n\n          if (firstNaNIndex < 0) {\n            firstNaNIndex = rawIndex;\n          }\n\n          continue;\n        } // Calculate triangle area over three buckets\n\n\n        area = Math.abs((pointAX - avgX) * (y - pointAY) - (pointAX - idx) * (avgY - pointAY));\n\n        if (area > maxArea) {\n          maxArea = area;\n          nextRawIndex = rawIndex; // Next a is this b\n        }\n      }\n\n      if (countNaN > 0 && countNaN < frameEnd - frameStart) {\n        // Append first NaN point in every bucket.\n        // It is necessary to ensure the correct order of indices.\n        newIndices[sampledIndex++] = Math.min(firstNaNIndex, nextRawIndex);\n        nextRawIndex = Math.max(firstNaNIndex, nextRawIndex);\n      }\n\n      newIndices[sampledIndex++] = nextRawIndex;\n      currentRawIndex = nextRawIndex; // This a is the next a (chosen b)\n    } // First frame use the last data.\n\n\n    newIndices[sampledIndex++] = this.getRawIndex(len - 1);\n    target._count = sampledIndex;\n    target._indices = newIndices;\n    target.getRawIndex = this._getRawIdx;\n    return target;\n  };\n  /**\n   * Large data down sampling on given dimension\n   * @param sampleIndex Sample index for name and id\n   */\n\n\n  DataStore.prototype.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n    var target = this.clone([dimension], true);\n    var targetStorage = target._chunks;\n    var frameValues = [];\n    var frameSize = Math.floor(1 / rate);\n    var dimStore = targetStorage[dimension];\n    var len = this.count();\n    var rawExtentOnDim = target._rawExtent[dimension] = getInitialExtent();\n    var newIndices = new (getIndicesCtor(this._rawCount))(Math.ceil(len / frameSize));\n    var offset = 0;\n\n    for (var i = 0; i < len; i += frameSize) {\n      // Last frame\n      if (frameSize > len - i) {\n        frameSize = len - i;\n        frameValues.length = frameSize;\n      }\n\n      for (var k = 0; k < frameSize; k++) {\n        var dataIdx = this.getRawIndex(i + k);\n        frameValues[k] = dimStore[dataIdx];\n      }\n\n      var value = sampleValue(frameValues);\n      var sampleFrameIdx = this.getRawIndex(Math.min(i + sampleIndex(frameValues, value) || 0, len - 1)); // Only write value on the filtered data\n\n      dimStore[sampleFrameIdx] = value;\n\n      if (value < rawExtentOnDim[0]) {\n        rawExtentOnDim[0] = value;\n      }\n\n      if (value > rawExtentOnDim[1]) {\n        rawExtentOnDim[1] = value;\n      }\n\n      newIndices[offset++] = sampleFrameIdx;\n    }\n\n    target._count = offset;\n    target._indices = newIndices;\n\n    target._updateGetRawIdx();\n\n    return target;\n  };\n  /**\n   * Data iteration\n   * @param ctx default this\n   * @example\n   *  list.each('x', function (x, idx) {});\n   *  list.each(['x', 'y'], function (x, y, idx) {});\n   *  list.each(function (idx) {})\n   */\n\n\n  DataStore.prototype.each = function (dims, cb) {\n    if (!this._count) {\n      return;\n    }\n\n    var dimSize = dims.length;\n    var chunks = this._chunks;\n\n    for (var i = 0, len = this.count(); i < len; i++) {\n      var rawIdx = this.getRawIndex(i); // Simple optimization\n\n      switch (dimSize) {\n        case 0:\n          cb(i);\n          break;\n\n        case 1:\n          cb(chunks[dims[0]][rawIdx], i);\n          break;\n\n        case 2:\n          cb(chunks[dims[0]][rawIdx], chunks[dims[1]][rawIdx], i);\n          break;\n\n        default:\n          var k = 0;\n          var value = [];\n\n          for (; k < dimSize; k++) {\n            value[k] = chunks[dims[k]][rawIdx];\n          } // Index\n\n\n          value[k] = i;\n          cb.apply(null, value);\n      }\n    }\n  };\n  /**\n   * Get extent of data in one dimension\n   */\n\n\n  DataStore.prototype.getDataExtent = function (dim) {\n    // Make sure use concrete dim as cache name.\n    var dimData = this._chunks[dim];\n    var initialExtent = getInitialExtent();\n\n    if (!dimData) {\n      return initialExtent;\n    } // Make more strict checkings to ensure hitting cache.\n\n\n    var currEnd = this.count(); // Consider the most cases when using data zoom, `getDataExtent`\n    // happened before filtering. We cache raw extent, which is not\n    // necessary to be cleared and recalculated when restore data.\n\n    var useRaw = !this._indices;\n    var dimExtent;\n\n    if (useRaw) {\n      return this._rawExtent[dim].slice();\n    }\n\n    dimExtent = this._extent[dim];\n\n    if (dimExtent) {\n      return dimExtent.slice();\n    }\n\n    dimExtent = initialExtent;\n    var min = dimExtent[0];\n    var max = dimExtent[1];\n\n    for (var i = 0; i < currEnd; i++) {\n      var rawIdx = this.getRawIndex(i);\n      var value = dimData[rawIdx];\n      value < min && (min = value);\n      value > max && (max = value);\n    }\n\n    dimExtent = [min, max];\n    this._extent[dim] = dimExtent;\n    return dimExtent;\n  };\n  /**\n   * Get raw data item\n   */\n\n\n  DataStore.prototype.getRawDataItem = function (idx) {\n    var rawIdx = this.getRawIndex(idx);\n\n    if (!this._provider.persistent) {\n      var val = [];\n      var chunks = this._chunks;\n\n      for (var i = 0; i < chunks.length; i++) {\n        val.push(chunks[i][rawIdx]);\n      }\n\n      return val;\n    } else {\n      return this._provider.getItem(rawIdx);\n    }\n  };\n  /**\n   * Clone shallow.\n   *\n   * @param clonedDims Determine which dims to clone. Will share the data if not specified.\n   */\n\n\n  DataStore.prototype.clone = function (clonedDims, ignoreIndices) {\n    var target = new DataStore();\n    var chunks = this._chunks;\n    var clonedDimsMap = clonedDims && reduce(clonedDims, function (obj, dimIdx) {\n      obj[dimIdx] = true;\n      return obj;\n    }, {});\n\n    if (clonedDimsMap) {\n      for (var i = 0; i < chunks.length; i++) {\n        // Not clone if dim is not picked.\n        target._chunks[i] = !clonedDimsMap[i] ? chunks[i] : cloneChunk(chunks[i]);\n      }\n    } else {\n      target._chunks = chunks;\n    }\n\n    this._copyCommonProps(target);\n\n    if (!ignoreIndices) {\n      target._indices = this._cloneIndices();\n    }\n\n    target._updateGetRawIdx();\n\n    return target;\n  };\n\n  DataStore.prototype._copyCommonProps = function (target) {\n    target._count = this._count;\n    target._rawCount = this._rawCount;\n    target._provider = this._provider;\n    target._dimensions = this._dimensions;\n    target._extent = clone(this._extent);\n    target._rawExtent = clone(this._rawExtent);\n  };\n\n  DataStore.prototype._cloneIndices = function () {\n    if (this._indices) {\n      var Ctor = this._indices.constructor;\n      var indices = void 0;\n\n      if (Ctor === Array) {\n        var thisCount = this._indices.length;\n        indices = new Ctor(thisCount);\n\n        for (var i = 0; i < thisCount; i++) {\n          indices[i] = this._indices[i];\n        }\n      } else {\n        indices = new Ctor(this._indices);\n      }\n\n      return indices;\n    }\n\n    return null;\n  };\n\n  DataStore.prototype._getRawIdxIdentity = function (idx) {\n    return idx;\n  };\n\n  DataStore.prototype._getRawIdx = function (idx) {\n    if (idx < this._count && idx >= 0) {\n      return this._indices[idx];\n    }\n\n    return -1;\n  };\n\n  DataStore.prototype._updateGetRawIdx = function () {\n    this.getRawIndex = this._indices ? this._getRawIdx : this._getRawIdxIdentity;\n  };\n\n  DataStore.internalField = function () {\n    function getDimValueSimply(dataItem, property, dataIndex, dimIndex) {\n      return parseDataValue(dataItem[dimIndex], this._dimensions[dimIndex]);\n    }\n\n    defaultDimValueGetters = {\n      arrayRows: getDimValueSimply,\n      objectRows: function (dataItem, property, dataIndex, dimIndex) {\n        return parseDataValue(dataItem[property], this._dimensions[dimIndex]);\n      },\n      keyedColumns: getDimValueSimply,\n      original: function (dataItem, property, dataIndex, dimIndex) {\n        // Performance sensitive, do not use modelUtil.getDataItemValue.\n        // If dataItem is an plain object with no value field, the let `value`\n        // will be assigned with the object, but it will be tread correctly\n        // in the `convertValue`.\n        var value = dataItem && (dataItem.value == null ? dataItem : dataItem.value);\n        return parseDataValue(value instanceof Array ? value[dimIndex] // If value is a single number or something else not array.\n        : value, this._dimensions[dimIndex]);\n      },\n      typedArray: function (dataItem, property, dataIndex, dimIndex) {\n        return dataItem[dimIndex];\n      }\n    };\n  }();\n\n  return DataStore;\n}();\n\nexport default DataStore;"],"mappings":"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"},"metadata":{},"sourceType":"module"}